import { FileSystem } from "@effect/platform";
import { Context, Effect, Layer, Ref } from "effect";
import {
  FileCacheStorage,
  makeFileCacheStorageLayer,
} from "../../lib/storage/FileCacheStorage";
import { PersistentService } from "../../lib/storage/FileCacheStorage/PersistantService";
import {
  type ParsedCommand,
  parseCommandXml,
  parsedCommandSchema,
} from "../parseCommandXml";
import { parseJsonl } from "../parseJsonl";
import type { SessionMeta } from "../types";
import { decodeSessionId } from "./id";

const ignoreCommands = [
  "/clear",
  "/login",
  "/logout",
  "/exit",
  "/mcp",
  "/memory",
];

const parsedCommandOrNullSchema = parsedCommandSchema.nullable();

export class SessionMetaService extends Context.Tag("SessionMetaService")<
  SessionMetaService,
  {
    readonly getSessionMeta: (
      projectId: string,
      sessionId: string,
    ) => Effect.Effect<SessionMeta, Error>;
    readonly invalidateSession: (
      projectId: string,
      sessionId: string,
    ) => Effect.Effect<void>;
  }
>() {
  static Live = Layer.effect(
    this,
    Effect.gen(function* () {
      const fs = yield* FileSystem.FileSystem;
      const firstCommandCache = yield* FileCacheStorage<ParsedCommand | null>();
      const sessionMetaCacheRef = yield* Ref.make(
        new Map<string, SessionMeta>(),
      );

      const extractFirstUserText = (
        conversation: Exclude<ReturnType<typeof parseJsonl>[0], undefined>,
      ): string | null => {
        if (conversation.type !== "user") {
          return null;
        }

        const firstUserText =
          typeof conversation.message.content === "string"
            ? conversation.message.content
            : (() => {
                const firstContent = conversation.message.content.at(0);
                if (firstContent === undefined) return null;
                if (typeof firstContent === "string") return firstContent;
                if (firstContent.type === "text") return firstContent.text;
                return null;
              })();

        return firstUserText;
      };

      const getFirstCommand = (
        jsonlFilePath: string,
        lines: string[],
      ): Effect.Effect<ParsedCommand | null, Error> =>
        Effect.gen(function* () {
          const cached = yield* firstCommandCache.get(jsonlFilePath);
          if (cached !== undefined) {
            return cached;
          }

          let firstCommand: ParsedCommand | null = null;

          for (const line of lines) {
            const conversation = parseJsonl(line).at(0);

            if (conversation === undefined) {
              continue;
            }

            const firstUserText = extractFirstUserText(conversation);

            if (firstUserText === null) {
              continue;
            }

            if (
              firstUserText ===
              "Caveat: The messages below were generated by the user while running local commands. DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to."
            ) {
              continue;
            }

            const command = parseCommandXml(firstUserText);
            if (command.kind === "local-command") {
              continue;
            }

            if (
              command.kind === "command" &&
              ignoreCommands.includes(command.commandName)
            ) {
              continue;
            }

            firstCommand = command;
            break;
          }

          if (firstCommand !== null) {
            yield* firstCommandCache.set(jsonlFilePath, firstCommand);
          }

          return firstCommand;
        });

      const getSessionMeta = (
        projectId: string,
        sessionId: string,
      ): Effect.Effect<SessionMeta, Error> =>
        Effect.gen(function* () {
          const metaCache = yield* Ref.get(sessionMetaCacheRef);
          const cached = metaCache.get(sessionId);
          if (cached !== undefined) {
            return cached;
          }

          const sessionPath = decodeSessionId(projectId, sessionId);
          const content = yield* fs.readFileString(sessionPath);
          const lines = content.split("\n");

          const firstCommand = yield* getFirstCommand(sessionPath, lines);

          const sessionMeta: SessionMeta = {
            messageCount: lines.length,
            firstCommand,
          };

          yield* Ref.update(sessionMetaCacheRef, (cache) => {
            cache.set(sessionId, sessionMeta);
            return cache;
          });

          return sessionMeta;
        });

      const invalidateSession = (
        _projectId: string,
        sessionId: string,
      ): Effect.Effect<void> =>
        Effect.gen(function* () {
          yield* Ref.update(sessionMetaCacheRef, (cache) => {
            cache.delete(sessionId);
            return cache;
          });
        });

      return {
        getSessionMeta,
        invalidateSession,
      };
    }),
  ).pipe(
    Layer.provide(
      makeFileCacheStorageLayer(
        "first-command-cache",
        parsedCommandOrNullSchema,
      ),
    ),
    Layer.provide(PersistentService.Live),
  );
}

export type ISessionMetaService = Context.Tag.Service<
  typeof SessionMetaService
>;
